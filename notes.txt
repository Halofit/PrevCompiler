
------------First------------------

No extensions plz
0x65 -> not a hex constant
	actually has to be recognised as
		0		-> int const
		x65		-> identifier

Any new function should be private in one file (one class)

xml -> [position] token, lexeme (when needed) representation
	position line,column of first and last character  ---> starts with one

call log before returning from lexAn() function to get xml

put xml & xsl into chrome to get visual report

Report errors with function in report or throw CompilerError

oddaja: 63120275-01.zip

NEEDS TO BE THE SAME STRUCTURE AS IN prev-01.zip
ADD three positive and three negative examples to Moodle

LEXER:


------------Second------------------

Parser -> Syntax analysis ll(1) parser

recursive descent
there must not be any left recursive productions
transform into ll(1) form from of lr(1) grammar
	- left recursion elimination
	- left factoring

Tool to check -> mdaines.github.io/grammophone/
Check parsing table
	- Transform -> try to get ll(1)

	Trick for left recursive problems:
		E -> E+T | E-T | T

				|
				|
				V

		E  -> TE'
		E' -> +TE' | -TE' | epsilon

Get parsing table ---> fuct for symbol -> switch(input) case options .... default: error

When writing functions for rules -> begLog, endLog

Error recovery ->
	- insert random correct symbol
	- delete tokens from id until we match
	- inspect what follows th next non-termal symbols
		(if T skip until find a symbol in Follow(T) -> then remove from stack) -> example skip until next ; in Java


------------Third------------------
E -> E+T | T
	|
	V
E -> T E'
E' -> eps |+ T E'


parseE()
	Expr op1 = parseT();
	Expr e = parseE'(op1);
	return e;

parseE'(Expr op1)
	case '+':
		skip('+');
		Expr op2 = parseT();
		Expr e = parseE'(new BinExpr(+, op1, op2));
		return e;

a[i] ->  (arr, a, i)
a.i  ->  (rec, a, i)

------------Fourth------------------

Semantic analyisis notes:
	EvalDecl: namespace scope in evalDecl
	EvalType: tipi


		a.c
			a-> v evalDecl
			c-> v evalType

		DECL(i) -> vrne deklaracijo i-ja
		DECL_tau(c) -> pogleda dekl v rekordu ?

		[[DECL(typ-name)]]_typ = Tau
		-------------
		[[typ-name]]_typ = Tau

			&&&

		[[type]]_typ = Tau
		-------------
		[[typ name:type]]_typ = Tau

			pomeni

		typ int:integer

		pravilo 3.4.1 2 pravilo -> integer -> tip integer
		pravilo 3.4.3 1 pravilo -> deklaracija je tipa integer

		var i: int

		int -> ime zato DECL(int) = type int:integer (kaže na deklaracijo -> name resolver to dobi)
		tip int-a je integer
		zato je vse tipa integer (3.4.3 3 pravilo)


	ZA RECORDE

		[[expr]]_typ = Tau [[DECL_tau(comp-name)]]_typ = Tau'   #implicitno vemo da je Tau record tipa, ker samo record naredi namespace
		-------------
		[[expr.comp-name]]_typ = Tau'

		var r:rec{i: integer}
				| |		\
				| |		 integer
				| \------------- vse je istga tipa
				\--------rec(integer)
		\----vse je rec(integer)

		r.i? ce je r ime
		| \
		|
		 \ tip je rec(integer)


	WHERE
		pri deklaracijah (najprej imena)
		tipi -> spremenljivke -> funkcije
		2 preleta -> najprej deklaracije (imena), nato implementacije

		typ a:b
		typ b:integer

		Prvi prelet:  TypDef(a,?), TypDef(b,?)
		Drugi prelet: TypDef(a, ? -> TypDef(b,?)) ugotovimo da je TypName(b,? -> IntegerTyp))

		IntegerTyp je atribut AtomType(INTEGER) ki je obešen na TypeDef
		TypName(b) pod TypDef(a) ima atribut kazalec na TypeName(b,?)

Typ.java
	actualType -> naj bi vrnu dejanski tip

------------Fifth------------------

Klcini zazpisi
	Ne za prototipe -> tist je že skompilan
	za vsako spremenljivko določimo njen dostop
	a je lokalna/globalna ->
		lokalne ->
		globalne -> določi labele (kaj je to?)

------------Linearisation------------------ (izpit break za implementirat) :)

Linearisation:
	CJUMP(L1,L2)  LABEL(L2) ... LABEL(L1)
		spremeniš v
	lahko v dva brancha + un branch na koncu bloka S1

	Maybe do basic blocks? -> not that hard
		kako najdt permutacijo? Požrešna metoda -> fiksiraš prvega, iščeš dorega naslednika
		če nimaš naslednika (ker je že fiksiran) -> poiščeš recimo eno še ne fixirano iz prejšnjega skoka)
			laho iščeš tudi če na kakšnega 2x skočiš ga ne boš porabu



	if C then S1 else S2
		CJUMP(L1, L2) LABEL(L1) ... S1 ... JUMP(L3) LABEL(L2) ...S2... LABEL(L3) ...

